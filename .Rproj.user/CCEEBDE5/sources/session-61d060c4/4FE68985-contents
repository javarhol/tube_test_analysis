#ModifiedCompete

library(tidyr)
library(dplyr)
library(reshape2)
library(compete)
library(steepness)
library(data.table)
library(xlsx)


#functions
Dominance <- function(x){
  matrix <- get_wl_matrix(x, ties="keep")
  DomScores <- as.data.frame(DavidScore(matrix, method = c("Dij","Pij")))
}

getWins <- function(x){
  matrix <- get_wl_matrix(x, ties="keep")
  totalwins <- as.data.frame(Wins(matrix))
}

Steep <- function(x){
  matrix <- get_wl_matrix(x, ties="keep")
  Steepdata <- as.data.frame(getStp(matrix, method = c("Dij","Pij")))
}

Landau <- function(x){
  matrix <- get_wl_matrix(x, ties="remove")
  devriesmod(matrix)
}

DC <- function(x){
  matrix <- get_wl_matrix(x, ties="keep")
  dc_compute(matrix)
}

DC_Matrix <- function(x){
  Matrix <- get_wl_matrix(x, ties="keep")
  dcmatrix(Matrix)
}


isiRank <- function(x){
  matrix <- get_wl_matrix(x, ties="keep")
  isi98(matrix, 100)
}


getMinRank <- function(x){
  matrix <- get_wl_matrix(x, ties="keep")
  Wins <- rowSums(matrix)
  TotalWins <- as.data.frame(Wins)
  TotalWins$ID <- rownames(TotalWins)
  TotalWins <- mutate(TotalWins, rank = rank(-Wins, ties.method="min"))
  TotalWins <- select(TotalWins, ID, Wins, rank)
  return(TotalWins)
}

devriesmod <- function(i) {
  
  # ensure matrix form
  m <- as.matrix(i)
  
  # replace NA values in diagonal with 0
  
  # compute total "encounters" (as sum of matrix with transpose)
  total <- m + t(m)
  
  # requires igraph
  g <- igraph::graph.adjacency(m, mode="directed", weighted=TRUE, diag=FALSE)
  
  # get number of rows (and columns)
  N <- nrow(m)
  NN <- N * N
  
  # store adjacency degree in d
  d <- igraph::degree(g, mode="out")
  
  # compute point-estimate of h
  hF1 <- (12 / ((N ^ 3) - N))
  hF2 <- (N - 1) / 2
  h <- hF1 * sum((d - hF2) ^ 2)
  
  # prepare arrays
  h0 <- vector(length=10000)
  hr <- vector(length=10000)
  
  # pre-compute matrices with fixed and random elements
  fixedels <- ((total > 0) + 0.0)
  randomels <- 1 - fixedels
  diag(randomels) <- 0
  
  # for fixed elements, the result is
  fixedvals <- fixedels * (0.5 * (((m > t(m)) + 0.0) - ((t(m) > m) + 0.0) + 1))
  
  # iterate over cases
  for (k in 1:10000){
    
    # compute new matrix
    randmat <- matrix(runif(NN), ncol=N)
    newmat <- fixedvals + randomels * ((randmat > t(randmat)) + 0.0)
    
    # compute sum over rows
    V <- rowSums(newmat)
    
    # apply formula
    h0[k] <- hF1 * sum((V - hF2) ^ 2)
    
    # compare with fully random matrix
    randmat <- matrix(runif(NN), ncol=N)
    nm <- (randmat > t(randmat)) + 0.0
    #diag(nm) = 0
    Vr <- rowSums(nm)
    hr[k] <- hF1 * sum((Vr - hF2) ^ 2)
  }
  
  # final computation
  t <- sum((hr >= h0) + 0.0)
  hmod <- mean(h0)
  p <- t / 10000
  
  return(hmod)
  #return(cat(" Landau's h= ",h,"\n","modified Landau's h= ",hmod,"\n","p-value from simulations= ",p))
  
}

Wins <- function (X, names = NULL) {
  if (nrow(X) != ncol(X)) 
    return("Error: Sociomatrix must be square")
  if (is.na(X) || !is.numeric(X)) 
    return("Error: Sociomatrix must be numeric")
  W <- rowSums(X)
  return(W)
}

DavidScore <- function (X, names = NULL, method = c("Dij", "Pij")) {
  if (nrow(X) != ncol(X)) 
    return("Error: Sociomatrix must be square")
  if (is.na(X) || !is.numeric(X)) 
    return("Error: Sociomatrix must be numeric")
  method <- match.arg(method)
  dyadc <- X + t(X)
  if (method == "Dij") {
    Dij <- X/dyadc - (((X/dyadc) - 0.5)/(dyadc + 1))
    Dij[is.nan(Dij)] <- 0
    w1 <- rowSums(Dij)
    w2 <- Dij %*% w1
    l1 <- colSums(Dij)
    l2 <- t(l1) %*% Dij
  }
  if (method == "Pij") {
    Pij <- array(dim = c(nrow(X), ncol(X)), 0)
    Pij <- X/dyadc
    Pij[is.nan(Pij)] <- 0
    w1 <- rowSums(Pij)
    w2 <- Pij %*% w1
    l1 <- colSums(Pij)
    l2 <- t(l1) %*% Pij
  }
  DS <- w1 + w2 - l1 - t(l2)
  maxDS <- nrow(X) * (nrow(X) - 1)/2
  NormDS <- (DS + maxDS)/nrow(X)
  return(NormDS)
}

cbindPad <- function(...){
  args <- list(...)
  n <- sapply(args,nrow)
  mx <- max(n)
  pad <- function(x, mx){
    if (nrow(x) < mx){
      nms <- colnames(x)
      padTemp <- matrix(NA, mx - nrow(x), ncol(x))
      colnames(padTemp) <- nms
      if (ncol(x)==0) {
        return(padTemp)
      } else {
        return(rbind(x,padTemp))
      }
    }
    else{
      return(x)
    }
  }
  rs <- lapply(args,pad,mx)
  return(do.call(cbind,rs))
}

dc_compute=function(Matrix){
  Matrix=as.matrix(Matrix)
  diag(Matrix)=0
  N=sum(Matrix)/2
  DC=sum(abs(Matrix-t(Matrix)))/2/sum(Matrix)
  S=(Matrix+t(Matrix))/2
  K=(Matrix-t(Matrix))/2
  phi=sum(diag(t(K)%*%K))/sum(diag(t(Matrix)%*%Matrix))
  #phi is the skew-symmetrical index
  si=1-phi
  #si is the symmetrical index
  #result=list(DC=DC,S=S,K=K,phi=phi,si=si)
  #return(result)
  return(DC)
}

dcmatrix=function(Matrix){
  Matrix=as.matrix(Matrix)
  diag(Matrix)=0
  DC=(abs(Matrix-t(Matrix)))/(Matrix+t(Matrix))
  return(DC)
}


isi<-function(M,nTries){
  n<-ncol(M)
  l=funisi(M)
  Imin=l[1];SImin=l[2]
  best=c(1:n)
  nTries=nTries%/%n
  for (jjj in 1:n){
    stopIteration1=FALSE;stopIteration2=FALSE
    index=sample(n,n);t=0
    matrix0=matrix_change(M,index); matrix1 = (matrix0-t(matrix0))/2
    while (stopIteration1==FALSE){
      while (stopIteration2==FALSE){
        stopIteration2<-TRUE
        
        for (i in 1:(n-1)){
          for (j in (i+1):n){
            if (matrix1[i,j]<0){
              sum1=sum(sign(matrix1[j,i:(j-1)]))
              if (sum1>0){
                matrix1=swap(matrix1,i,j)
                change=index[i];index[i]=index[j];index[j]=change
                stopIteration2=FALSE
              }
            }
          }
        }
      }
      l<-funisi(matrix1)
      I=l[1];SI=l[2]
      if ((I<Imin)|((I==Imin)&(SI<SImin))){
        best=list()
        best[[1]]=index
        Imin=I
        SImin=SI
        stopIteration1=FALSE
      }
      else if((I==Imin)&(SI==SImin)){
        t=t+1
        best[[length(best)+1]]=index
      }
      else{
        t=t+1
      }
      if ((SImin>0)&(t<nTries)){
        for(j in 2:n){
          kk=matrix1[j,1:(j-1)]
          if (max(kk>0)){
            rand=sample((j-1),1)
            matrix1=swap(matrix1,rand,j)
            change=index[rand];index[rand]=index[j];index[j]=change
            stopIteration1=FALSE
          }
        }
      }
      else{
        stopIteration1=TRUE
      }
    }
  }
  best=unique(best)
  correlation=rep(0,length(best))
  for (k in 1:length(best)){
    correlation[k]=cor.test(nature(M),best[[k]])$p.value
  }
  num<-which(correlation==min(correlation))
  result_1=list()
  result_2=list()
  for (i in 1:length(num)){
    result_1[[i]]=matrix_change(M,best[[num[i]]])
    result_2[[i]]=best[[num[i]]]
  }
  res <- as.data.frame(result)
  res$Rank <- rownames(res)
  return(res)
  #answer=list(best_matrix=result_1,best_order=result_2,I=Imin,SI=SImin)
}

funisi<-function(M){
  n=ncol(M)
  result=rep(0,2)
  k = M
  k[upper.tri(k)]=0
  result[1] = sum(k>0)
  a=length(which(k>0))
  y=which(k>0)%%n
  x=(which(k>0)-1)%/%n+1
  y[y==0]=y[y==0]+n
  if (a>0){
    result[1]=a
    result[2]=sum(y-x)
  }
  return(result)
}

matrix_change<-function(M,sequence){
  n=ncol(M)
  new_matrix<-NULL
  for(i in 1:n){
    temp<-M[sequence[i],]
    temp<-temp[sequence]
    new_matrix<-rbind(new_matrix,temp)
  }
  return(new_matrix)
}

swap<-function(M,i,j){
  result=M
  k=result[i,];result[i,]=result[j,];result[j,]=k
  k=result[,i];result[,i]=result[,j];result[,j]=k
  return(result)
}

nature<-function(M){
  n=ncol(M)
  index=c(1:n)
  D<-rep(0,n)
  S<-rep(0,n)
  for (i in 1:n){
    fast<-M-t(M)
    D[i]=D[i]+length(which(sign(fast[i,])==1))
    S[i]=S[i]+length(which(sign(fast[i,])==-1))
  }
  result=D/(D+S)
  save=sort(result,decreasing=TRUE,index.return=TRUE)
  sequence=save$ix
  result=save$x
  Dom_sub=D-S
  for (i in 1:(n-1)){
    if (result[i]==result[i+1]){
      if (Dom_sub[i]<Dom_sub[i+1]){
        mid<-sequence[i];sequence[i]=sequence[i+1];sequence[i+1]=mid
      }
    }
  }
  return(sequence)
}

#' import data into R where all cages for the corresponding day (7,14,21) are in one table. 
#' then break each cage into it's own dataframe. 
#' build a matrix for each cage for each day tested, where individuals are labeled 1-5 and the number of wins is across

CE_Raw <- read.xlsx("C:/Justin/Google Drive/Vetsuisse/_Social Hierarchy Project/_Exp1/Data/CombinedData10.05.16.xlsx", sheetName="CETrialOutcomes!")
CE_Raw <- read.xlsx("/Users/justinvarholick/Google Drive/Vetsuisse/*Social Hierarchy Project/*Exp1/Data/CombinedData10.05.16.xlsx", sheetName = "CETrialOutcomes!")
CE_Raw <- slice(CE_Raw, 1:546)
CE_Rank <- read.xlsx("C:/Justin/Google Drive/Vetsuisse/_Social Hierarchy Project/_Exp1/Data/CombinedData10.05.16.xlsx", sheetName="Outcomes by Rank3")
CE_Rank <- read.xlsx("/users/justinvarholick/Google Drive/Vetsuisse/*Social Hierarchy Project/*Exp1/Data/CombinedData10.05.16.xlsx", sheetName="Outcomes by Rank3")


#format data
CE_Data <- CE_Raw %>%
  select(Test.Day,Cage, Opponent.1, Opponent.2, T1, T2, T3, T4) %>%
  within(ID <- paste(Cage, Test.Day, sep = "-")) %>%
  select(Opponent.1, Opponent.2, T1, T2, T3, T4, ID, Cage)
CE_Data$Opponent.1 <- paste(CE_Data$Cage, CE_Data$Opponent.1, sep="-")
CE_Data$Opponent.2 <- paste(CE_Data$Cage, CE_Data$Opponent.2, sep="-")

long_data <- data.frame(CE_Data[1:2], CE_Data[7], CE_Data[8], stack(CE_Data[3:6]))
long_data <- long_data[,c("Opponent.1", "Opponent.2", "values", "ind", "ID", "Cage")]

#split up long_data by ID
df_list <- split(long_data, as.factor(long_data$ID))

#splitup long_dat by Cage (compound all 3 weeks)
df_list2 <- split(long_data, as.factor(long_data$Cage))

#get minimum Ranks (go back and manually assess ties)
#each day
Ranks <- do.call(rbind, lapply(df_list, getMinRank))
write.xlsx(Ranks, "C:/Justin/Google Drive/Vetsuisse/_Social Hierarchy Project/_Exp1/Data/Uncombined Data/MinRank12.05.16.xlsx", sheetName = "by wk")
#each cage
Ranks2 <- do.call(rbind, lapply(df_list2, getMinRank))
write.xlsx(Ranks2, "C:/Justin/Google Drive/Vetsuisse/_Social Hierarchy Project/_Exp1/Data/Uncombined Data/MinRank12.05.16.xlsx", sheetName = "ac wk", append=TRUE)

#get I&SI ranks 
#each day
ISIRanks <- do.call(rbind, lapply(df_list, isiRank))
write.xlsx(ISIRanks, "C:/Justin/Google Drive/Vetsuisse/_Social Hierarchy Project/_Exp1/Data/Uncombined Data/ISIRank13.05.16.xlsx", sheetName = "by wk")
#each cage
ISIRanks2 <- do.call(rbind, lapply(df_list2, isiRank))
write.xlsx(ISIRanks2, "C:/Justin/Google Drive/Vetsuisse/_Social Hierarchy Project/_Exp1/Data/Uncombined Data/ISIRank13.05.16.xlsx", sheetName = "ac wk2", append=TRUE)


#NormDS
#each day
DavidData <- do.call(rbind, lapply(df_list, Dominance))
write.xlsx(DavidData, "C:/Justin/Google Drive/Vetsuisse/Social Hierarchy Project/Exp1/Data/Uncombined Data/DavidScores10.05.16.xlsx", sheetName = "by wk")
#each cage
DavidData2 <- do.call(rbind, lapply(df_list2, Dominance))
write.xlsx(DavidData2, "C:/Justin/Google Drive/Vetsuisse/Social Hierarchy Project/Exp1/Data/Uncombined Data/DavidScores10.05.16.xlsx", sheetName = "ac wk", append=TRUE)

#Wins
#each day
WinData <- do.call(rbind, lapply(df_list, getWins))
write.xlsx(WinData, "C:/Justin/Google Drive/Vetsuisse/_Social Hierarchy Project/_Exp1/Data/Uncombined Data/WinData15.09.16.xlsx", sheetName = "by wk")
#each cage
WinData2 <- do.call(rbind, lapply(df_list2, getWins))
write.xlsx(WinData2, "C:/Justin/Google Drive/Vetsuisse/_Social Hierarchy Project/_Exp1/Data/Uncombined Data/WinData15.09.16.xlsx", sheetName = "ac wk", append=TRUE)



#Steepness
#each day
Steepdata <- do.call(rbind, lapply(df_list, Steep))
write.xlsx(Steepdata, "C:/Justin/Google Drive/Vetsuisse/Social Hierarchy Project/Exp1/Data/Uncombined Data/SteepnessData10.05.16.xlsx", sheetName="by wk")
#each cage
Steepdata2 <- do.call(rbind, lapply(df_list2, Steep))
write.xlsx(Steepdata2, "C:/Justin/Google Drive/Vetsuisse/Social Hierarchy Project/Exp1/Data/Uncombined Data/SteepnessData10.05.16.xlsx", sheetName="ac wk", append=TRUE)

#Landau
#each day
LanduaData <- do.call(rbind, lapply(df_list, Landau))
write.xlsx(LanduaData, "C:/Justin/Google Drive/Vetsuisse/Social Hierarchy Project/Exp1/Data/LandauData.xlsx", sheetName = "by wk")
#each cage
LandauData2 <- do.call(rbind, lapply(df_list2, Landau))
write.xlsx(LandauData2, "C:/Justin/Google Drive/Vetsuisse/Social Hierarchy Project/Exp1/Data/LandauData.xlsx", sheetName = "ac wk", append=TRUE)

#DC
#each day
DCdata <- do.call(rbind, lapply(df_list, DC))
write.xlsx(DCdata, "C:/Justin/Google Drive/Vetsuisse/Social Hierarchy Project/Exp1/Data/DCData.xlsx", sheetName = "by wk")
#each cage
DCdata2 <- do.call(rbind, lapply(df_list2, DC))
write.xlsx(DCdata2, "C:/Justin/Google Drive/Vetsuisse/Social Hierarchy Project/Exp1/Data/DCData.xlsx", sheetName = "ac wk", append=TRUE)

#DC per relationship based on Rank
CE_Rank <- CE_Rank %>%
  select(Cage, Sex, o1ID, o2ID, o1R, o2r, T1, T2, T3, T4)
CE_Rank$Sex <- as.factor(CE_Rank$Sex)
CE_Rank$Cage <- as.numeric(CE_Rank$Cage)

males <- filter(CE_Rank, Sex=="Male")
males <- filter(males, Cage!=77)
males <- filter(males, Cage!=38)
females <- filter(CE_Rank, Sex=="Female")

long_RankMales <- data.frame(males[5:6], stack(males[7:10]))
long_RankMales$o1R <- as.factor(long_RankMales$o1R)
long_RankMales$o2r <- as.factor(long_RankMales$o2r)

long_RankFemales <- data.frame(females[5:6], stack(females[7:10]))
long_RankFemales$o1R <- as.factor(long_RankFemales$o1R)
long_RankFemales$o2r <- as.factor(long_RankFemales$o2r)

#only use top half of matrix, bottom half is top half - 1
DCMales <- DC_Matrix(long_RankMales)
DCFemales <- DC_Matrix(long_RankFemales)
write.xlsx(DCMales, "/users/justinvarholick/Google Drive/Vetsuisse/*Social Hierarchy Project/*Exp1/Data/DCData.xlsx", sheetName = "males", append=TRUE)
write.xlsx(DCFemales, "/users/justinvarholick/Google Drive/Vetsuisse/*Social Hierarchy Project/*Exp1/Data/DCData.xlsx", sheetName = "females", append=TRUE)
#make sure to do edits on bottom half


#############################################################
#for missing data

#for cage 110 on day 3, remove 110-4
md1 <- filter(long_data, ID=="110-3")
md1 <- filter(md1, Opponent.1!="110-4")
md1 <- filter(md1, Opponent.2!="110-4")
md1matrix <- get_wl_matrix(md1, ties="keep")

md11 <- filter(long_data, Cage=="110")
md11 <- filter(md11, ID!="110-3")
md111 <- rbind(md1, md11)

md111matrix <- get_wl_matrix(md111, ties="keep")

DavidScore(md1matrix)
getStp(md1matrix)
devriesmod(md1matrix)
dc_compute(md1matrix)

DavidScore(md111matrix)
getStp(md111matrix)
devriesmod(md111matrix)
dc_compute(md111matrix)

md2 <- filter(long_data, ID=="149-2")
md2 <- filter(md2, Opponent.2!="149-4")
md2 <- filter(md2, Opponent.1!="149-4")
md2matrix <- get_wl_matrix(md2, ties="keep")

md22 <- filter(long_data, Cage=="149")
md22 <- filter(md22, ID!="149-2")
md222 <- rbind(md2, md22)
md222matrix <- get_wl_matrix(md222, ties="keep")

DavidScore(md2matrix)
getStp(md2matrix)
devriesmod(md2matrix)
dc_compute(md2matrix)

DavidScore(md222matrix)
getStp(md222matrix)
devriesmod(md222matrix)
dc_compute(md222matrix)

########SANDBOX AND OLD UNNECESSARY CODE#######################

test <- filter(long_data, ID=="41-1")
row_sub = apply(test,1, function(row) all(row !=0))
test <- test[row_sub,]

M <- get_wl_matrix(test, ties="keep")

####



getMinRank(test)



######

test <- filter(long_data, ID=="77-3")
Dom <- Dominance(test)
test2 <- filter(long_data, ID=="110-3")
test <- filter(long_data, ID=="38-1")



#run David's Score for each ID
for (i in df_list){
  if (!exists("DomScores")){
    DomScores <- Dominance(i)
  }
  if (exists("DomScores")){
    tempScores <- Dominance(i)
    DomScores <- cbindPad(DomScores, tempScores)
    rm(tempScores)
  }
}
write.xlsx(DomScores, "C:/Justin/Google Drive/Vetsuisse/Social Hierarchy Project/Exp1/Data/DomScoresNew.xlsx")

#is Landau score significant?
LandauSigs <- do.call(rbind, lapply(df_list, SigLandau))
write.xlsx(LandauSigs, "C:/Justin/Google Drive/Vetsuisse/Social Hierarchy Project/Exp1/Data/DevriesPvalues.xlsx")

#get IDs of cages
IDs <- as.data.frame(eval.parent(quote(names(df_list))))